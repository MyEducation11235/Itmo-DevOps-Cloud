# Лабораторная работа №2 со звёздочкой
## Задание
* Написать “плохой” Docker compose файл, в котором есть не менее трех “bad practices” по их написанию.
* Написать “хороший” Docker compose файл, в котором эти плохие практики исправлены.
* В хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта поднимались вместе, но не "видели" друг друга по сети.

## Выполнили студенты
* Зюзин Владислав
* Недиков Михаил 
* Поскуряков Роман

## Установка Docker compose

Первым делом устанавливаем Docker, если ещё не установили, лучший гайд по установке представлен на видео по ссылке: https://yandex.ru/video/preview/3719090281561281090  
После этого устанавливаем Docker compose на ОС. В нашем случае это Linux, а именно Ubuntu:24.04, которую мы запускаем через VirtualBox.
Не забываем проверить обновления, благодаря вводу команды: 
```
sudo apt get update
```
Далее уже можно установить Docker compose, введём поочерёдно команды:
```
mkdir -p ~/.docker/cli-plugins/
```
```
curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose
```
```
chmod +x ~/.docker/cli-plugins/docker-compose
```
На рисунке ниже представлен код и его вывод, а так же проверка установки Docker compose

![1](1.png)

## Написание Docker compose файла

### Пара слов прр Docker compose

Docker Compose — это инструмент, предназначенный для удобного управления контейнерами Docker. Он особенно полезен для работы со средами, в которых задействовано несколько контейнеров, но также подходит для управления отдельными контейнерами. С его помощью можно изолировать окружения, одновременно запускать, пересобирать и останавливать контейнеры, отслеживать их состояние и пользоваться множеством других полезных функций, упрощающих работу с контейнерами.

### Как с ним работать?

Начнём с базовового, нужно создать пределённую папку, в которую вы сложите свои скрипты, а так же docker-compose файл, который будет запускать их. mkdir script1 script2
С помощью команд
```
mkdir lab2*
```
после переходим через `cd lab2*` в созданную директорию
```
mkdir bad
```
посмотрим на то, что мы сделали ранее и переходим в нужную директорию.
Мы создали директорию, в которой будем хранить скрипты и запускать `docker-compose.yml.`. Далее создаём директории для скриптов: 
``` 
mkdir script1 script2
```
Заходим поочерёдно в директории, вводим в терминал команду: 
```
gedit script1.bash
```
Мы внесли следующий код: 
```
#!/bin/bash

echo "Container 1 is working!"
ping -c 2 8.8.8.8
```
Почему пинг? Потому что в последнем задании нам предстоит проверять связь между докерами, т.о. мы создали два сервиса, которые выполняют простой скрипт на языке bash, который сначала выводит в консоль сообщение о том, что контейнер работает, а также его номер, а потом с помощью утилиты ping проверяет соединение с интернетом.

По аналогии заодим в script2, создаём и заполняем файл script1.bash следующим кодом: 
```
#!/bin/bash

echo "Container 2 is working!"
ping -c 2 8.8.8.8
```
Далее возвращаемся в директорию `\lab2*\bad\`, там создаём `docker-compose.yml`, в который заносим такой код: 

```
version: '2'
services:
  My_cont_1:
    image: ubuntu:latest  # Используем тег :latest, что является плохой практикой
    privileged: true  # Запуск контейнера с привилегиями (плохая практика)
    volumes:
      - ./script1:/container_folder  # Монтируем локальный файл без правильных прав доступа
    command: >
      /bin/bash -c
      "apt-get update && apt-get install -y bash &&
      apt-get install -y iputils-ping && bash /container_folder/script1.bash"

  My_cont_2:
    image: ubuntu:latest  # Используем тег :latest
    privileged: true  # Запуск контейнера с привилегиями
    volumes:
      - ./script2:/container_folder  # Монтируем локальный файл без правильных прав доступа
    command: >
      /bin/bash -c
      "apt-get update && apt-get install -y bash &&
      apt-get install -y iputils-ping && bash /container_folder/script2.bash"
```
### Кстати, почему же он плохой?
**1. Использование тега `latest` для образа**

*Непредсказуемость*: Тег latest всегда будет ссылаться на последнюю доступную версию образа. Это может привести к тому, что в будущем версия образа изменится, и ваш контейнер будет строиться на совершенно другой версии с новыми зависимостями и поведением.

*Отсутствие контроля*: Использование latest нарушает принцип стабильности и управляемости. Когда образ обновляется, он может неожиданно повлиять на ваш проект, изменив его поведение.

*Проблемы с совместимостью*: На разных машинах может быть установлена разная версия Docker, и использование latest может привести к различным версиям образа на разных системах, что усложнит тестирование и поддержку проекта.

**2. Запуск контейнера с привилегиями (privileged: true)**

*Риски безопасности*: Когда контейнер запускается с привилегиями, он получает доступ ко всем устройствам и ресурсам хостовой машины, что увеличивает вероятность использования контейнера для атаки на хост. Привилегированные контейнеры могут выполнять операции, которые не должны быть доступны в обычных контейнерах, такие как монтирование устройств или доступ к чувствительным данным хоста.

*Нарушение изоляции*: Одной из главных целей использования контейнеров является изоляция процессов. Включение привилегий нарушает эту изоляцию и может привести к сбоям в работе хостовой системы или другим контейнерам.

*Необходимость в привилегиях*: Использование привилегированного режима следует избегать, если нет веской причины для его использования. В большинстве случаев контейнеру не нужно таких прав для выполнения обычных задач.

**3. Монтирование локальных файлов без правильных прав доступа**

*Конфликт прав доступа*: Локальные файлы и директории на хосте могут иметь права доступа, несовместимые с контейнером. Например, если файлы на хосте доступны только для чтения, а контейнер попытается их изменить, это приведет к ошибке. Это может создать дополнительные сложности при работе в разных средах.

*Безопасность и уязвимости*: Когда контейнер монтирует локальные файлы с хоста, это увеличивает вероятность утечек данных или доступа к уязвимым файлам. Если контейнер не ограничен в доступе к этим файлам, он может выполнить несанкционированные операции на хосте.

*Нарушение переносимости*: Монтирование локальных файлов с хоста делает контейнер менее переносимым. В других средах или на других машинах, где структура директорий или права доступа могут отличаться, это может вызвать проблемы.

Теперь, что достаточно полезно - введите команды: 
```
chmod +x ~/lab2*/bad/script1/script1.bash
```
```
chmod +x ~/lab2*/bad/script2/script2.bash
```
Это нужно, чтобы ваши скрипты имели 100500% шанс на выполнение, они, оказывается, не всегда имеют на это право, крч, введите и не парьтесь
Ну и наконец, то, на что было потрачено где то часа 2:
```
sudo docker compose up
```

### Полезные команды

Далее при выполнении лабораторной работы так же использовались команды:

1. sudo docker system prune

Данная команда удаляет из системы всю информацию про докеры. Это позволяет запускать новые докеры, не опасаясь, что на устройстве закончится память. 

2. sudo docker stop <название первого контейнера> <название второго контейнера>

Вторая же команда позволяет останавливать контейнеры. После их остановки можно поменять файл docker-compose.yml и другие файлы, которые файлы, с которыми взаимодействуют контейнеры, и после этого запустить их снова. Это так же будет экономить время и место на компьютере, ведь контейнерам не придётся запускаться заново с нуля. Если нужно сделать незначительное изменение в коде, то при запуске на контейнер уже не будет скачиваться операционная система и ранее установленные утилиты. Важно не забывать, что к указанным в docker-compose.yml названиям сервисов в начале надо добавлять "<путь до директории, в которой лежит наш файл>-", а в конце - "-1".

## Плохой Docker compose файл

Плохой docker-compose.yml:
